<!-- --------------------------------  Q1:  -------------------------------- -->

1. Explain the difference between controlled and uncontrolled components in React with an example use case for each. Answer:
In React, there are two types of form components: controlled and uncontrolled.

1. Controlled Component

In this type, the value of the input is controlled by React using state useState.
Whatever we type in the input box goes into the state first, and then React shows it again in the input.
This is useful when we want to check or validate the input while the user is typing.

Example use case: Login form because we want to control and validate what the user types.
function ControlledExample() {
  const [name, setName] = React.useState("");

  return (
    <div>
      <h3>Controlled</h3>
      <input 
        type="text" 
        value={name} 
        onChange={(e) => setName(e.target.value)} 
      />
      <p>You typed: {name}</p>
    </div>
  );
}


2. Uncontrolled Component

React does not control the input.
The input keeps its own value just like normal HTML.
If we want the value, we take it using ref.
This is useful when we don’t need to track the value every time, only when submitting.

Example use case: File upload form we just take the file when needed.

function UncontrolledExample() {
  const inputRef = React.useRef();

  const showValue = () => {
    alert("You typed: " + inputRef.current.value);
  };

  return (
    <div>
      <h3>Uncontrolled</h3>
      <input type="text" ref={inputRef} />
      <button onClick={showValue}>Show Value</button>
    </div>
  );
}

<!-- --------------------------------  Q2:  -------------------------------- -->


2. What is the difference between React Context and Redux? When would you use one over the other?
Answer:
React Context and Redux are both used to manage state, but they are different.

1. React Context:

Built into React.
Used for simple state sharing between components (like theme, user info, language).
Good when the app is small or medium and data is not too complex.

2. Redux:

A separate library.
Used for large and complex applications where many components need to read and update the same data.
Provides features like middleware, debugging tools, and strict rules for updating state.

 When to use Context: If you only need to pass simple data (like theme = dark/light) to many components.
 When to use Redux: If your app has a lot of data changes (like e-commerce cart, notifications, API data) and you need strong state management.

 <!-- --------------------------------  Q3:  -------------------------------- -->


3. Why does React need a key prop in lists? What issues can occur if keys are not used properly?
Answer:
In React, when we show a list of items using .map(), we need to give each item a special prop called key.
The key helps React identify each item uniquely.
React uses it to know which items changed, added, or removed, so it can update the UI faster.

* What happens if keys are not used properly:
React may re-render the whole list unnecessarily, which makes the app slower.
It can also cause bugs:
Wrong items getting updated.
Input fields losing focus.
Components not keeping their correct state.

<!-- --------------------------------  Q4:  -------------------------------- -->


4. What are React Hooks rules, and why do we need them? Give an example of breaking the rules.
Answer :

we must follow when using hooks like useState, useEffect, etc.

Rules of Hooks :

Only call hooks at the top level
Don't put hooks inside loops, conditions (if), or nested functions.
They must always run in the same order.
Only call hooks from React functions
You can use hooks only inside React components or custom hooks.
Don't use them in normal JavaScript functions.

* Why do we need these rules :

React uses the order of hooks to keep track of state and effects.
If we break the rules, React won’t know which state belongs to which hook, and it causes bugs or crashes.

Example of Breaking the Rules:
 Wrong :
function Example({ show }) {
  if (show) {
    const [count, setCount] = React.useState(0); //  breaks the rules
  }
  return <div>Hello</div>;
}

 Correct:
function Example({ show }) {
  const [count, setCount] = React.useState(0); //  always at top level

  return <div>{show && <p>Count: {count}</p>}</div>;
}

<!-- --------------------------------  Q5:  -------------------------------- -->

5. Explain the difference between useMemo and useCallback with examples.

Answer:
Both useMemo and useCallback are React hooks used for performance optimization, but they are different.

useMemo :

useMemo returns a value.
It is used to memoize (remember) the result of a calculation so it doesn’t run again unless dependencies change.
Good for expensive (heavy) calculations.

Example:

import React, { useMemo, useState } from "react";

function UseMemoExample() {
  const [count, setCount] = useState(0);

  // Expensive calculation 
  const double = useMemo(() => {
    console.log("Calculating...");
    return count * 2;
  }, [count]);

  return (
    <div>
      <p>Count: {count}</p>
      <p>Double: {double}</p>
      <button onClick={() => setCount(count + 1)}>Increase</button>
    </div>
  );
}


useCallback:

useCallback returns a function.
It is used when we want to memoize a function so that it is not recreated every render.
Useful when passing functions as props to child components.


 Example:

import React, { useCallback, useState } from "react";

function UseCallbackExample() {
  const [count, setCount] = useState(0);

  // Memoized function 
  const increment = useCallback(() => {
    setCount(c => c + 1);
  }, []);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increase</button>
    </div>
  );
}







